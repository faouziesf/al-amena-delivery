<?php

namespace App\Services;

use App\Models\Ticket;
use App\Models\TicketMessage;
use App\Models\Complaint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class TicketIntegrationService
{
    /**
     * Cr√©er automatiquement un ticket depuis une r√©clamation
     */
    public function createTicketFromComplaint(Complaint $complaint): Ticket
    {
        return DB::transaction(function () use ($complaint) {
            // D√©terminer la priorit√© bas√©e sur la r√©clamation
            $priority = $this->mapComplaintPriorityToTicket($complaint);

            // Cr√©er le ticket
            $ticket = Ticket::create([
                'type' => 'COMPLAINT',
                'subject' => "R√©clamation #{$complaint->complaint_code} - {$this->getComplaintTypeDisplay($complaint->type)}",
                'description' => $complaint->description,
                'priority' => $priority,
                'client_id' => $complaint->client_id,
                'complaint_id' => $complaint->id,
                'package_id' => $complaint->package_id,
                'assigned_to_id' => $complaint->assigned_commercial_id,
                'status' => $complaint->assigned_commercial_id ? 'IN_PROGRESS' : 'OPEN'
            ]);

            // Message initial automatique
            $initialMessage = $this->generateInitialMessage($complaint);

            TicketMessage::create([
                'ticket_id' => $ticket->id,
                'sender_id' => $complaint->client_id,
                'sender_type' => 'CLIENT',
                'message' => $initialMessage,
                'is_internal' => false,
                'metadata' => [
                    'auto_created' => true,
                    'source' => 'complaint_integration',
                    'complaint_id' => $complaint->id
                ]
            ]);

            // Log de l'int√©gration
            Log::info('Ticket cr√©√© automatiquement depuis r√©clamation', [
                'ticket_id' => $ticket->id,
                'complaint_id' => $complaint->id,
                'client_id' => $complaint->client_id
            ]);

            return $ticket;
        });
    }

    /**
     * Synchroniser le statut entre r√©clamation et ticket
     */
    public function syncComplaintTicketStatus(Complaint $complaint): void
    {
        if (!$complaint->ticket) {
            return;
        }

        $ticket = $complaint->ticket;

        // Logique de synchronisation bas√©e sur le statut de la r√©clamation
        switch ($complaint->status) {
            case 'PENDING':
                if ($ticket->status === 'CLOSED') {
                    $ticket->update(['status' => 'IN_PROGRESS']);
                }
                break;

            case 'IN_PROGRESS':
                if (in_array($ticket->status, ['OPEN', 'CLOSED'])) {
                    $ticket->update(['status' => 'IN_PROGRESS']);
                }
                break;

            case 'RESOLVED':
                if ($ticket->status !== 'CLOSED') {
                    $ticket->markAsResolved();
                }
                break;

            case 'CANCELLED':
                if ($ticket->status !== 'CLOSED') {
                    $ticket->close();

                    // Message automatique
                    TicketMessage::create([
                        'ticket_id' => $ticket->id,
                        'sender_id' => 1, // Syst√®me
                        'sender_type' => 'SUPERVISOR',
                        'message' => 'Ticket ferm√© automatiquement suite √† l\'annulation de la r√©clamation associ√©e.',
                        'is_internal' => true,
                        'metadata' => [
                            'auto_sync' => true,
                            'reason' => 'complaint_cancelled'
                        ]
                    ]);
                }
                break;
        }
    }

    /**
     * Obtenir tous les tickets li√©s aux r√©clamations d'un client
     */
    public function getClientComplaintTickets($clientId)
    {
        return Ticket::where('client_id', $clientId)
                    ->where('type', 'COMPLAINT')
                    ->whereNotNull('complaint_id')
                    ->with(['complaint', 'messages' => function($q) {
                        $q->orderBy('created_at', 'desc')->limit(1);
                    }])
                    ->orderBy('created_at', 'desc')
                    ->get();
    }

    /**
     * V√©rifier si une r√©clamation peut cr√©er un ticket
     */
    public function canComplaintCreateTicket(Complaint $complaint): bool
    {
        // V√©rifier si un ticket n'existe pas d√©j√†
        if ($complaint->ticket()->exists()) {
            return false;
        }

        // V√©rifier si la r√©clamation est dans un √©tat permettant la cr√©ation de ticket
        return in_array($complaint->status, ['PENDING', 'IN_PROGRESS']);
    }

    /**
     * Cr√©er un ticket d'urgence depuis une r√©clamation critique
     */
    public function createUrgentTicketFromComplaint(Complaint $complaint, string $reason): Ticket
    {
        $ticket = $this->createTicketFromComplaint($complaint);

        // Marquer comme urgent
        $ticket->markAsUrgent("R√©clamation critique: " . $reason);

        // Message d'urgence
        TicketMessage::create([
            'ticket_id' => $ticket->id,
            'sender_id' => $complaint->client_id,
            'sender_type' => 'CLIENT',
            'message' => "üö® SITUATION URGENTE\n\nRaison: {$reason}\n\nCette r√©clamation n√©cessite une attention imm√©diate.",
            'is_internal' => false,
            'metadata' => [
                'urgent_escalation' => true,
                'escalation_reason' => $reason
            ]
        ]);

        return $ticket;
    }

    /**
     * Obtenir les statistiques d'int√©gration r√©clamations-tickets
     */
    public function getIntegrationStats(): array
    {
        $totalComplaints = Complaint::count();
        $complaintsWithTickets = Complaint::has('ticket')->count();

        return [
            'total_complaints' => $totalComplaints,
            'complaints_with_tickets' => $complaintsWithTickets,
            'integration_rate' => $totalComplaints > 0 ? round(($complaintsWithTickets / $totalComplaints) * 100, 2) : 0,
            'tickets_from_complaints' => Ticket::where('type', 'COMPLAINT')->whereNotNull('complaint_id')->count(),
            'urgent_complaint_tickets' => Ticket::where('type', 'COMPLAINT')
                                                ->where('status', 'URGENT')
                                                ->whereNotNull('complaint_id')
                                                ->count()
        ];
    }

    /**
     * Notification automatique pour les commerciaux sur les nouveaux tickets de r√©clamation
     */
    public function notifyCommercialNewComplaintTicket(Ticket $ticket): void
    {
        if (!$ticket->complaint || !$ticket->assignedTo) {
            return;
        }

        // Ici on pourrait int√©grer avec le syst√®me de notifications existant
        // Par exemple, cr√©er une notification dans la base de donn√©es
        // ou envoyer un email au commercial assign√©

        Log::info('Notification commercial nouveau ticket r√©clamation', [
            'ticket_id' => $ticket->id,
            'commercial_id' => $ticket->assigned_to_id,
            'complaint_id' => $ticket->complaint_id
        ]);
    }

    /**
     * Mapper la priorit√© de r√©clamation vers priorit√© de ticket
     */
    private function mapComplaintPriorityToTicket(Complaint $complaint): string
    {
        // Si la r√©clamation a une priorit√© d√©finie
        if (isset($complaint->priority)) {
            return match($complaint->priority) {
                'LOW' => 'LOW',
                'NORMAL' => 'NORMAL',
                'HIGH' => 'HIGH',
                'URGENT' => 'URGENT',
                default => 'NORMAL'
            };
        }

        // Sinon, d√©terminer bas√© sur le type de r√©clamation
        return match($complaint->type) {
            'DAMAGE' => 'HIGH',
            'LOST_PACKAGE' => 'HIGH',
            'DELAY' => 'NORMAL',
            'COD_ISSUE' => 'HIGH',
            'ADDRESS_ERROR' => 'NORMAL',
            'DELIVERY_ISSUE' => 'NORMAL',
            'OTHER' => 'NORMAL',
            default => 'NORMAL'
        };
    }

    /**
     * G√©n√©rer le message initial du ticket bas√© sur la r√©clamation
     */
    private function generateInitialMessage(Complaint $complaint): string
    {
        $message = "R√©clamation automatiquement convertie en ticket.\n\n";
        $message .= "üìã **D√©tails de la r√©clamation:**\n";
        $message .= "- Code: {$complaint->complaint_code}\n";
        $message .= "- Type: {$this->getComplaintTypeDisplay($complaint->type)}\n";

        if ($complaint->package) {
            $message .= "- Colis: {$complaint->package->package_code}\n";
        }

        $message .= "- Statut: {$complaint->status}\n";
        $message .= "- Cr√©√©e le: {$complaint->created_at->format('d/m/Y H:i')}\n\n";

        $message .= "üìù **Description:**\n{$complaint->description}\n\n";

        if ($complaint->additional_data && !empty($complaint->additional_data)) {
            $message .= "‚ÑπÔ∏è **Donn√©es suppl√©mentaires:**\n";
            foreach ($complaint->additional_data as $key => $value) {
                $message .= "- {$key}: {$value}\n";
            }
        }

        return $message;
    }

    /**
     * Obtenir l'affichage du type de r√©clamation
     */
    private function getComplaintTypeDisplay(string $type): string
    {
        return match($type) {
            'DAMAGE' => 'Colis endommag√©',
            'LOST_PACKAGE' => 'Colis perdu',
            'DELAY' => 'Retard de livraison',
            'COD_ISSUE' => 'Probl√®me COD',
            'ADDRESS_ERROR' => 'Erreur d\'adresse',
            'DELIVERY_ISSUE' => 'Probl√®me de livraison',
            'OTHER' => 'Autre',
            default => $type
        };
    }
}